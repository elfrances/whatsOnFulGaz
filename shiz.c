#include <errno.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/queue.h>
#include <sys/stat.h>
#include <time.h>
#include <unistd.h>

#include "args.h"
#include "json.h"
#include "shiz.h"

// GPS Track Point
typedef struct TrkPt {
    TAILQ_ENTRY(TrkPt) tqEntry;   // node in the trkPtList
    int index;          // TrkPt index (0..N-1)
    time_t timestamp;   // in seconds since the Epoch
    double latitude;    // in degrees decimal
    double longitude;   // in degrees decimal
    double elevation;   // elevation from sea level (in meters)
    double speed;       // speed (in m/s)
    double distance;    // distance from start (in meters)
    double grade;       // actual grade (in %)
    double bearing;     // initial bearing / forward azimuth (in degrees decimal)
} TrkPt;

// GPS Track (sequence of Track Points)
typedef struct GpsTrk {
    // Working list of TrkPt's
    TAILQ_HEAD(TrkPtList, TrkPt) trkPtList;

    // Number of TrkPt's in trkPtList
    int numTrkPts;

    // Activity's start/end times
    double startTime;
    double endTime;
} GpsTrk;

static const char *fmtTrkPtObj(const JsonObject *pObj)
{
#define FMT_BUF_LEN 1024
    static char fmtBuf[FMT_BUF_LEN];
    const char *sp = pObj->start;
    char *dp = fmtBuf;

    for (int n = 0; (sp <= pObj->end) && (n <= (FMT_BUF_LEN - 2)); n++) {
        *dp++ = *sp++;
    }

    *dp = '\0';

    return fmtBuf;
}

static TrkPt *trkPtNew(int index)
{
    TrkPt *pTrkPt;

    if ((pTrkPt = calloc(1, sizeof(TrkPt))) == NULL) {
        fprintf(stderr, "Failed to alloc TrkPt object !!!\n");
        return NULL;
    }

    pTrkPt->index = index;

    return pTrkPt;
}

static void trkPtFree(TrkPt *pTrkPt)
{
    free(pTrkPt);
}

static GpsTrk *gpsTrkNew(void)
{
    GpsTrk *pTrk = calloc(1, sizeof(GpsTrk));

    if (pTrk != NULL) {
        TAILQ_INIT(&pTrk->trkPtList);
    }

    return pTrk;
}

static void gpsTrkFree(GpsTrk *pTrk)
{
    TrkPt *pTrkPt;

    while ((pTrkPt = TAILQ_FIRST(&pTrk->trkPtList)) != NULL) {
        TAILQ_REMOVE(&pTrk->trkPtList, pTrkPt, tqEntry);
        trkPtFree(pTrkPt);
    }
}

static const char *xmlHeader = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n";

static const char *gpxHeader = "<gpx creator=\"whatsOnFulGaz\" version=\"%s\"\n"
                               "  xsi:schemaLocation=\"http://www.topografix.com/GPX/1/1 http://www.topografix.com/GPX/11.xsd\"\n"
                               "  xmlns:ns3=\"http://www.garmin.com/xmlschemas/TrackPointExtension/v1\"\n"
                               "  xmlns=\"http://www.topografix.com/GPX/1/1\"\n"
                               "  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:ns2=\"http://www.garmin.com/xmlschemas/GpxExtensions/v3\">\n";

static int createGpxFile(const char *title, const char *shizPath, const GpsTrk *pTrk)
{
    char gpxPath[256];
    FILE *fp;
    time_t now;
    struct tm brkDwnTime = {0};
    char timeBuf[128];
    TrkPt *p;

    snprintf(gpxPath, sizeof (gpxPath), "%s.gpx", shizPath);
    if ((fp = fopen(gpxPath, "w")) == NULL) {
        fprintf(stderr, "Failed to create GPX file!\n");
        return -1;
    }

    now = time(NULL);
    strftime(timeBuf, sizeof (timeBuf), "%Y-%m-%dT%H:%M:%S", gmtime_r(&now, &brkDwnTime));

    // Print headers
    fprintf(fp, "%s", xmlHeader);
    fprintf(fp, gpxHeader, PROGRAM_VERSION);

    // Print metadata
    fprintf(fp, "  <metadata>\n");
    fprintf(fp, "    <author>whatsOnFulGaz version %s [https://github.com/elfrances/whatsOnFulGaz.git]</author>\n", PROGRAM_VERSION);
    fprintf(fp, "    <desc>Autogenerated GPX file from its corresponding SHIZ file.</desc>\n");
    fprintf(fp, "    <time>%s</time>\n", timeBuf);
    fprintf(fp, "  </metadata>\n");

    // Print track
    fprintf(fp, "  <trk>\n");
    fprintf(fp, "    <name>%s</name>\n", title);
    fprintf(fp, "    <type>1</type>\n");   // Biking

    // Print track segment
    fprintf(fp, "    <trkseg>\n");

    // Print all the track points
    TAILQ_FOREACH(p, &pTrk->trkPtList, tqEntry) {
        fprintf(fp, "      <trkpt lat=\"%.10lf\" lon=\"%.10lf\">\n", p->latitude, p->longitude);
        fprintf(fp, "        <ele>%.10lf</ele>\n", p->elevation);
        fprintf(fp, "      </trkpt>\n");
    }

    fprintf(fp, "    </trkseg>\n");

    fprintf(fp, "  </trk>\n");

    fprintf(fp, "</gpx>\n");

    fclose(fp);

    printf("INFO: Created GPX file \"%s\"\n", gpxPath);

    return 0;
}

static int procTrkPtObj(const JsonObject *pObj, void *arg)
{
    GpsTrk *pTrk = arg;
    TrkPt *pTrkPt;
    time_t time;

    //printf("trkpt: %s\n", fmtTrkPtObj(pObj));

    // Alloc new TrkPt object
    if ((pTrkPt = trkPtNew(pTrk->numTrkPts++)) == NULL) {
        fprintf(stderr, "ERROR: Failed to create TrkPt object !!!\n");
        return -1;
    }

    // The format of the "trkpt" object varies depending on the version
    // of the app used to create the shiz file, but it looks more or less
    // like this:
    //
    // {"-lon":"5.280152","-lat":"44.174612","speed":"13.9","ele":"1876.6","distance":"20.719","bearing":"239.8","slope":"6.2","time":"02:03:59","index":7439}
    //
    // In some shiz files the numeric values are not strings but actual
    // integer/float numbers, so we allow for either format...

    if ((jsonGetStrDoubleValue(pObj, "-lon", &pTrkPt->longitude) != 0) &&
        (jsonGetDoubleValue(pObj, "-lon", &pTrkPt->longitude) != 0)) {
        fprintf(stderr, "ERROR: Can't get longitude value: %s\n", fmtTrkPtObj(pObj));
        return -1;
    }

    if ((jsonGetStrDoubleValue(pObj, "-lat", &pTrkPt->latitude) != 0) &&
        (jsonGetDoubleValue(pObj, "-lat", &pTrkPt->latitude) != 0)) {
        fprintf(stderr, "ERROR: Can't get latitude value: %s\n", fmtTrkPtObj(pObj));
        return -1;
    }

    if ((jsonGetStrDoubleValue(pObj, "speed", &pTrkPt->speed) != 0) &&
        (jsonGetDoubleValue(pObj, "speed", &pTrkPt->speed) != 0)) {
        fprintf(stderr, "ERROR: Can't get speed value: %s\n", fmtTrkPtObj(pObj));
        return -1;
    }

    if ((jsonGetStrDoubleValue(pObj, "ele", &pTrkPt->elevation) != 0) &&
        (jsonGetDoubleValue(pObj, "ele", &pTrkPt->elevation) != 0)) {
        fprintf(stderr, "ERROR: Can't get elevation value: %s\n", fmtTrkPtObj(pObj));
        return -1;
    }

    if ((jsonGetStrDoubleValue(pObj, "distance", &pTrkPt->distance) != 0) &&
        (jsonGetDoubleValue(pObj, "distance", &pTrkPt->distance) != 0)) {
        fprintf(stderr, "ERROR: Can't get distance value: %s\n", fmtTrkPtObj(pObj));
        return -1;
    }

    if ((jsonGetStrDoubleValue(pObj, "bearing", &pTrkPt->bearing) != 0) &&
        (jsonGetDoubleValue(pObj, "bearing", &pTrkPt->bearing) != 0)) {
        fprintf(stderr, "ERROR: Can't get bearing value: %s\n", fmtTrkPtObj(pObj));
        return -1;
    }

    if ((jsonGetStrDoubleValue(pObj, "slope", &pTrkPt->grade) != 0) &&
        (jsonGetDoubleValue(pObj, "slope", &pTrkPt->grade) != 0)) {
        fprintf(stderr, "ERROR: Can't get slope value: %s\n", fmtTrkPtObj(pObj));
        return -1;
    }

    if (jsonGetStrTimeValue(pObj, "time", &time) != 0) {
        fprintf(stderr, "ERROR: Can't get time value: %s\n", fmtTrkPtObj(pObj));
        return -1;
    }

    pTrkPt->timestamp = time;
    pTrkPt->distance *= 1000.0; // convert from km to m
    pTrkPt->speed *= 0.277778;  // convert from km/h to m/s

    // Insert track point at the tail of the queue
    TAILQ_INSERT_TAIL(&pTrk->trkPtList, pTrkPt, tqEntry);

    return 0;
}

typedef struct InFile {
    const char *filePath;
    char *data;
    size_t dataLen;
} InFile;

// Read the entire input file into a buffer
static int readInFile(InFile *inFile)
{
    int fd;
    struct stat stBuf = {0};

    if ((fd = open(inFile->filePath, O_RDONLY, 0)) < 0) {
        fprintf(stderr, "ERROR: can't open file \"%s\" (%s)\n", inFile->filePath, strerror(errno));
        return -1;
    }

    if (fstat(fd, &stBuf) != 0) {
        fprintf(stderr, "ERROR: can't get file size (%s)\n", strerror(errno));
        return -1;
    }

    inFile->dataLen = stBuf.st_size;

    if ((inFile->data = malloc(inFile->dataLen)) == NULL) {
        fprintf(stderr, "ERROR: can't alloc data buffer (%s)\n", strerror(errno));
        return -1;
    }

    if (read(fd, inFile->data, inFile->dataLen) != inFile->dataLen) {
        fprintf(stderr, "ERROR: can't read data (%s)\n", strerror(errno));
        free(inFile->data);
        return -1;
    }

    close(fd);

    return 0;
}

// Parse the SHIZ file and create a list of Track Points (TrkPt's)
static GpsTrk *parseShizFile(const char *filePath)
{
    InFile inFile = { .filePath = filePath };
    GpsTrk *pTrk = NULL;
    JsonObject mainObj = {0};
    JsonObject trkpt = {0};

    if (readInFile(&inFile) != 0) {
        // Error message already printed
        return NULL;
    }

    // Locate the main JSON object
    //if (jsonFindObject(inFile.data, inFile.dataLen, &mainObj) != 0) {
    //    fprintf(stderr, "ERROR: can't find main JSON object!\n");
    //    free(inFile.data);
    //    return NULL;
    //}

    mainObj.start = inFile.data;
    mainObj.end = mainObj.start + inFile.dataLen - 1;

    // Get the "trkpt" array which contains all
    // the trackpoint objects.
    if (jsonFindArrayByTag(&mainObj, "trkpt", &trkpt) != 0) {
        fprintf(stderr, "ERROR: can't find \"trkpt\" array object!\n");
        free(inFile.data);
        return NULL;
    }

    if ((pTrk = gpsTrkNew()) == NULL) {
        fprintf(stderr, "ERROR: can't alloc GpsTrk object!\n");
        free(inFile.data);
        return NULL;
    }

    //jsonDumpObject(&trkpt);

    // Process each entry in the "trkpt" array ...
    jsonArrayForEach(&trkpt, procTrkPtObj, pTrk);

    // We don't need this anymore ...
    free(inFile.data);

    return pTrk;
}

int shizToGpx(const char *title, const char *filePath)
{
    GpsTrk *pTrk = NULL;

    // Parse the shiz file
    if ((pTrk = parseShizFile(filePath)) == NULL) {
        fprintf(stderr, "ERROR: failed to parse shiz file!\n");
        return -1;
    }

    // Create the GPX file
    createGpxFile(title, filePath, pTrk);

    gpsTrkFree(pTrk);

    return 0;
}




